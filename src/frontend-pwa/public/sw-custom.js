self.addEventListener('install', (event) => {
  // self.skipWaiting();
})

/**
 * @summary Supplemental service-worker file. Appends functionality to
 *          the service-worker generated by the VitePWA "generateSW"
 *          strategy.
 * 
 * @author  Tyler Maloney
 */

/**
 * @summary Handles splitting of workbox precache into "mapTiles" cache consisting of
 *          map tiles, and the "site" cache which contains everything else from precache.
 *
 *          Deletes the original file from precache after it has been moved to ensure
 *          cache size remains below 50mb limit (iOS Safari limitation).
 *          After the files have been moved to the separate caches, the empty precache
 *          is deleted.
 *          
 * @param  'activate' is the event which this listener will listen for.
 *         This event fires as soon as the service-worker is finished precaching assets
 *         and is functional.
 * @type   {event}
 * @author Tyler Maloney
 */
 self.addEventListener('activate', (event) => {
  // self.clients.claim();
//   event.waitUntil(
//     self.clients.claim().then(() => {
//       return caches.open('mapTiles').then((mapTilesCache) => {
//         return caches.open('site').then((siteCache) => {
//           return caches.keys().then((cacheNames) => {
//             const precacheNames = cacheNames.filter((cacheName) => cacheName.startsWith('workbox-precache-v2'));
//             return Promise.all(
//               precacheNames.map((precacheName) => {
//                 return caches.open(precacheName).then((precache) => {
//                   return precache.keys().then((cacheKeys) => {
//                     const mapTilesUrls = cacheKeys.filter((cacheKey) => cacheKey.url.includes('mapTiles'));
//                     const siteUrls = cacheKeys.filter((cacheKey) => !cacheKey.url.includes('mapTiles'));

//                     const mapTilesPromises = mapTilesUrls.map((url) => {
//                       return precache.match(url).then((response) => {
//                         if (response) {
//                           return mapTilesCache.put(url, response.clone()).then(() => {
//                             return precache.delete(url);
//                           });
//                         }
//                       });
//                     });

//                     const sitePromises = siteUrls.map((url) => {
//                       return precache.match(url).then((response) => {
//                         if (response) {
//                           return siteCache.put(url, response.clone()).then(() => {
//                             return precache.delete(url);
//                           });
//                         }
//                       });
//                     });

//                     return Promise.all([...mapTilesPromises, ...sitePromises]);
//                   });
//                 });
//               })
//             );
//           });
//         });
//       }).then(() => {
//         return caches.keys().then((cacheNames) => {
//           const precacheNamesToDelete = cacheNames.filter((cacheName) => cacheName.startsWith('workbox-precache-v2'));
//           return Promise.all(
//             precacheNamesToDelete.map((cacheName) => {
//               return caches.delete(cacheName);
//             })
//           );
//         });
//       }).then(() => {
//       }).catch((error) => {
//         console.error('Error deleting caches:', error);
//       });
//     })
//   );
 });

/**
* @summary Deletes the "mapTiles" cache, through an event linked to the
*          "Delete Data" button in the "Delete Mapping Data"
*          accordion tab.
*          
* @param  'message' is the event which this listener will listen for.
*         The message event is used in a page controlled by a 
*         service worker to receive messages from the service worker.
* @type  {event}
* @author Tyler Maloney
*/
// self.addEventListener('message', (event) => {
// if (event.data && event.data.action === 'clearCache') {
//   caches.keys().then((cacheNames) => {
//     const cachesToDelete = cacheNames.filter((cacheName) => cacheName === 'mapTiles');
//     return Promise.all(cachesToDelete.map((cacheName) => caches.delete(cacheName)));
//   }).then(() => {
//     event.source.postMessage({ action: 'clearCache', success: true });
//   }).catch((error) => {
//     console.error('Cache clear error:', error);
//     event.source.postMessage({ action: 'clearCache', error });
//   });
// }
// });
//below code will delete basic precache, alternate solution
self.addEventListener('message', (event) => {
  if (event.data && event.data.action === 'clearCache') {
    caches.keys().then((cacheNames) => {
      const precacheNamesToDelete = cacheNames.filter((cacheName) => cacheName.startsWith('workbox-precache-v2'));
          return Promise.all(
            precacheNamesToDelete.map((cacheName) => {
              return caches.delete(cacheName);
            })
          );
    }).then(() => {
      event.source.postMessage({ action: 'clearCache', success: true });
    }).catch((error) => {
      console.error('Cache clear error:', error);
      event.source.postMessage({ action: 'clearCache', error });
    });
  }
  });
